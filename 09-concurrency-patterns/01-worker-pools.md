# Worker Pools

## 1Ô∏è‚É£ Simple Explanation (Beginner Friendly)

A **worker pool** limits concurrent work by having a fixed number of workers processing jobs from a queue.

```go
// Instead of unlimited goroutines:
for _, job := range jobs {
    go process(job)  // 1 million goroutines!
}

// Use worker pool:
for w := 0; w < 10; w++ {
    go worker(jobs)  // Only 10 workers
}
```

---

## 2Ô∏è‚É£ Real-World Analogy

### üç≥ Restaurant Kitchen

Without pool: Hire a new chef for each order = chaos!
With pool: 5 chefs process orders from queue = controlled.

---

## 3Ô∏è‚É£ Technical Working (Step-by-Step)

### Worker Pool Pattern

```
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ          Job Queue             ‚îÇ
                    ‚îÇ    [job][job][job][job]        ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚ñº              ‚ñº           ‚ñº           ‚ñº              ‚ñº
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇWorker 1 ‚îÇ   ‚îÇWorker 2 ‚îÇ  ‚îÇWorker 3 ‚îÇ  ‚îÇWorker 4 ‚îÇ  ‚îÇWorker 5 ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ              ‚îÇ           ‚îÇ           ‚îÇ              ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ        Results Channel         ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 4Ô∏è‚É£ Where Used in Real Systems?

### Image Processing Service

```go
func processImages(images []Image) []Result {
    jobs := make(chan Image, len(images))
    results := make(chan Result, len(images))
    
    // Start workers
    for w := 0; w < runtime.GOMAXPROCS(0); w++ {
        go func() {
            for img := range jobs {
                results <- resize(img)
            }
        }()
    }
    
    // Send jobs
    for _, img := range images {
        jobs <- img
    }
    close(jobs)
    
    // Collect results
    var out []Result
    for range images {
        out = append(out, <-results)
    }
    return out
}
```

---

## 5Ô∏è‚É£ Practical Examples

### Basic Worker Pool

```go
func worker(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
        fmt.Printf("Worker %d processing job %d\n", id, j)
        time.Sleep(time.Second)
        results <- j * 2
    }
}

func main() {
    jobs := make(chan int, 100)
    results := make(chan int, 100)
    
    // Start 3 workers
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }
    
    // Send 9 jobs
    for j := 1; j <= 9; j++ {
        jobs <- j
    }
    close(jobs)
    
    // Collect results
    for a := 1; a <= 9; a++ {
        <-results
    }
}
```

### With Context Cancellation

```go
func worker(ctx context.Context, jobs <-chan Job) {
    for {
        select {
        case <-ctx.Done():
            return
        case job, ok := <-jobs:
            if !ok {
                return
            }
            process(job)
        }
    }
}
```

---

## 6Ô∏è‚É£ Common Mistakes & Interview Traps

| ‚ùå Wrong | ‚úÖ Correct |
|---------|-----------|
| Forget to close jobs | Close after sending all jobs |
| Wrong result count | Match results to jobs count |
| No context support | Add ctx.Done() select |

---

## 7Ô∏è‚É£ Quick Summary Box

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Worker Pool:                               ‚îÇ
‚îÇ ‚Ä¢ Fixed number of workers                  ‚îÇ
‚îÇ ‚Ä¢ Jobs channel as queue                    ‚îÇ
‚îÇ ‚Ä¢ Results channel for output               ‚îÇ
‚îÇ                                            ‚îÇ
‚îÇ Benefits:                                  ‚îÇ
‚îÇ ‚Ä¢ Bounded concurrency                      ‚îÇ
‚îÇ ‚Ä¢ Controlled resource usage                ‚îÇ
‚îÇ ‚Ä¢ Backpressure via channel blocking        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 8Ô∏è‚É£ Quiz Questions

1. Why use worker pool vs unlimited goroutines?
2. What happens if you forget to close jobs channel?
3. How to choose number of workers?
4. How does backpressure work?
5. How to handle worker errors?

---

## 9Ô∏è‚É£ Answer Key

<details>
<summary>Click to reveal answers</summary>

**A1**: Control resources, prevent exhaustion, bounded memory.

**A2**: Workers block forever on range loop.

**A3**: CPU-bound: GOMAXPROCS. IO-bound: higher (10x-100x CPU count).

**A4**: Full jobs channel blocks sender until workers catch up.

**A5**: Send errors via results channel or dedicated error channel.

</details>

---

[‚Üê Previous Module](../08-context/05-context-in-real-applications.md) | [Next ‚Üí](./02-fan-in-fan-out.md)
